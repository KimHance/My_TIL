# 인터페이스와 추상 클래스 생성

## 인터페이스 만들기

코틀린 클래스의 static 메소드가 컴패니언 객체에 들어있는 것과 유사하게 인터페이스 역시 인터페이스 안에 컴패니언 객체를 작성하여 static 메소드를 가질 수 있다.

인터페이스를 구현하는 어떤 클래스라도 추상 메소드를 오버라이드해야만 한다.

구현된 메소드는 구현하지 않아도 상관없고, 오버라이드가 필요한 경우에만 오버라이드 하면 된다.

코틀린에서 static 메소드를 인터페이스 안에 직접 만들 수 없다. 이는 클래스 안에 static 메소드를 직접 작성할 수 없는 것과 동일하다. 

인터페이스를 구현할 때는 모든 추상 메소드를 구현해야 한다. 

여러개의 인터페이스를 구현할 때는 충돌하는 모든 메소드를 클래스에 구현해야 한다.

## 추상 클래스 생성하기

인터페이스에 정의된 속성엔 백킹 필드가 없다. 인터페이스는 구현 클래스로 부터 속성을 억는 추상 메소드에 의존한다. 반면에 추상 클래스는 백킹 필드를 가진다.

인터페이스는 한 번에 여러 개를 구현할 수 있지만, 클래스는 추상 클래스든지 일반 클래스든지 하나만 확장 가능하다.

## 인터페이스? 추상 클래스?

인터페이스는 필드를 가질 수 없지만 클래스에서 여러 개의 인터페이스를 한 번에 구현할 수 있다.

반면 추상 클래스는 필드를 가질 수 있지만 한 번에 하나의 클래스만 확장할 수 있다.

여러 클래스 사이에어 상태를 다시 사용해야 한다면 추상 클래스가 좋은 선택이다. 추상 클래스에서는 공통 상태를 구현할 수 있다. 

클래스에서 구현할 때 추상 클래스가 제공해 주는 상태를 재사용하며 메소드를 오버라이드한다.

하나 이상의 명세와 요구사항을 만족하는 클래스들을 원하지만 각각의 클래스들이 각각의 구현을 하는 것을 원한다면 인터페이스가 좋은 선택이다.

클래스들이 각각의 상태를 구현하게 하면서 공통 메소드를 인터페이스에 옮겨놓을 수 있다.

인터페이스가 추상 클래스보다 약간의 이점을 가지고 있다.

인터페이스는 메소드를 상태와 상관없이 구현할 수 있는 능력이 있다. 

클래스는 여러개의 인터페이스를 구현할 수 있다.

유연성을 위해서는 가능한 추상 클래스, 베이스 클래스를 사용하는 것보다 인터페이스를 사용하는 편이 좋다