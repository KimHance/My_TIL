# 클래스 생성

## 필드와 속성

코틀린에서는 클래스에 필드가 없다 

클래스의 속성을 호출하려면 .으로 바로 접근하는것이 아니라 getter 를 통해 호출한 것이다.

그치만 코틀린에선 getter , setter 대신 속성의 이름을 이용해서 속성에 접근할 수 있다.

## 접근 제어자

코틀린에는 public, private, protected, internal 네 개의 접근 제어자가 있다.

protected 는 파생 클래스들의 메소드가 속성에 접근할 수 있는 권한을 준다.

internal 은 같은 모듈에 있는 모든 코드에서 속성이나 메소드에 접근이 가능하다.

getter 의 접근 권한은 속성의 접근 권한과 동일하다.

setter 의 경우 개발자가 원하는 대로 접근 권한을 설정할 수 있다.

## 초기화 코드

객체를 초기화하는 코드가 값들을 설정하는 것보다 더 복잡하다면 생성자용 바디를 만들 필요가 있다. 

코틀린은 0개 이상의 init블록을 가질 수 있다.

이 블록들은 주 생성자의 실행의 한 부분으로써 실행된다.

init 블록 코드는 top-down 으로 순차적으로 실행된다.

하지만 클래스 내부에서 선언된 속성을 사용하기 위해서는 init 블록을 속성 선언 아래에 위치시켜야 한다.

init 블록을 여러 개를 정의할 수 있다 하지만 그 뜻이 반드시 init 블록을 정의하라는 뜻은 아니다. 클래스 안에서 첫 번째로 속성을 가장 위에 정의하도록 하고, 그 후에 init 블록을 작성하고 보조 생성자를 구현하도록 한다. 마지막으로 필요한 메소드를 작성하면 된다.

## 보조 생성자

주 생성자가 없다면 아규먼트가 없는 기본 생성자를 생성한다. 만약 주 생성자가 모든 파라미터를 위한 기본 아규먼트를 가지고 있다면 코틀린은 주 생성자와 함께 아규먼트가 없는 생성자를 생성한다.

보조 생성자는 주 생성자를 호출하거나, 다른 보조 생성자를 호출해야만 한다.

보조 생성자의 파라미터도 역시 val, 이나 var 을 사용할 수 없다.

보조 생성자는 속성을 선언할 수 없다.

보조 생성자는 주 생성자나 보조 생성자를 호출할 수 있다. 단, 생성자끼리 서로를 호출하는 순환은 일어나선 안된다.

## 인라인 클래스

클래스는 추상화를 나타낸다. 

inline 클래스는 균형을 잡게 해주는 좋은 기능이다. 컴파일 시간에는 클래스의 장점을 취할 수 있고, 런타임에는 프리미티브 타입으로 취급된다.